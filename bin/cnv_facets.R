#!/usr/bin/env Rscript
#
# Copyright (C) 2018 University of Glasgow
#
# Author: Dario Beraldi <dario.beraldi@glasgow.ac.uk>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.

suppressMessages(library(argparse))

# -----------------------------------------------------------------------------

VERSION= sprintf('0.8.0; facets %s', packageVersion('facets'))

docstring<- sprintf('DESCRIPTION \\n\\
Detect copy number variants (CNVs) and estimate purity and ploidy in a tumour\\n\\
sample givn a tumour-normal pair. The analysis is based on the facets method\\n\\
(https://github.com/mskcc/facets).\\n\\
\\n\\
Input:\\n\\
\\n\\
* Either a pair of bam file for the tumour and matched normal sample and a vcf\\n\\
  file of SNP positions\\n\\
\\n\\
* Or a csv file of counts generated by the accompanying program snp-pileup\\n\\
\\n\\
See the online documentation for more details and usage.\\n\\
Version %s', VERSION)

parser<- ArgumentParser(description= docstring, formatter_class= 'argparse.RawTextHelpFormatter')

parser$add_argument('--out', '-o', help= 'Output prefix for the output files', required= TRUE)

parser$add_argument('--tumour', '-t', help= 'BAM file for tumour sample. Ignored if using --pileup', required= FALSE)
parser$add_argument('--normal', '-n', help= 'BAM file for normal sample. Ignored if using --pileup', required= FALSE)

parser$add_argument('--snp-vcf', '-vcf', help= 'VCF file of SNPs where pileup is to be computed. Ignored if using --pileup required otherwise', required= FALSE)

def<- 100
parser$add_argument('--snp-pseudo', '-P', help= sprintf('If there is no SNP every MULTIPLE positions, insert a \\n\\
blank record with the total count at that position. Ignored if using --pileup. Default %s', def), 
                    required= FALSE, default= def, type= 'integer')

def<- 0
parser$add_argument('--snp-mapq', '-mq', help= sprintf('Sets the minimum threshold for mapping quality. Ignored if using --pileup. Default %s', def), required= FALSE, default= def, type= 'integer')

def<- 0
parser$add_argument('--snp-baq', '-bq', help= sprintf('Sets the minimum threshold for base quality. Ignored if using --pileup. Default %s', def), required= FALSE, default= def, type= 'integer')

def<- 0
parser$add_argument('--snp-min-read-norm', '-rn', help= sprintf('Minimum read count in normal bam for a position to be output. Ignored if using --pileup. Default %s', def), required= FALSE, default= def, type= 'integer')

def<- 0
parser$add_argument('--snp-min-read-tum', '-rt', help= sprintf('Minimum read count in tumour bam for a position to be output. Ignored if using --pileup. Default %s', def), required= FALSE, default= def, type= 'integer')

parser$add_argument('--pileup', '-p', help= 'Pileup for matched normal (first sample) and tumour (second sample). \\n\\
This is the output of the snp-pileup program accompanying facets.', required= FALSE)

def<- c(25, 4000)
parser$add_argument('--depth', '-d', help= sprintf('Minimum and maximum depth in normal sample for a position to be considered. Default %s', paste(def, collapse= ' ')), type= 'integer', default= def, nargs= 2)

def<- c(25, 150)
parser$add_argument('--cval', '-cv', help= sprintf("Critical values for segmentation in pre-processing and processing.\\n\\
Larger values reduce segmentation. [25 150] is facets default based on exome data. For whole genome\\n\\
consider increasing to [25 400] and for targeted sequencing consider reducing them. Default %s", paste(def, collapse= ' ')), type= 'double', default= def, nargs= 2)

def<- 250 
parser$add_argument('--nbhd-snp', '-snp', help= sprintf('If an interval of size nbhd-snp contains more than one SNP, sample a random one.\\n\\
This sampling reduces the SNP serial correlation. This value should be similar\\n\\
to the median insert size of the libraries. 250 is facets default based on\\n\\
exome data. For whole genome consider increasing to 500 and for target\\n\\
sequencing decrease to 150. Default %s', def), type= 'integer', default= def)

parser$add_argument('--fai', '-f', help= sprintf('Tab separated file listing reference contigs (1st column) and their size (2nd column). \\n\\
The genome fasta index .fai is suitable. This option is used to write contigs \\n\\
in the VCF header, not required but recommended. If NULL and bam files are used \\n\\
in input, contigs are taken from the bam header.'), type= 'character', required= FALSE)

def<- 'hg38'
parser$add_argument('--gbuild', '-g', help= sprintf('String indicating the reference genome build. Chromosomes used for analysis are \\n\\
1-22, X for humans and 1-19 for mouse. Default %s.', def), 
    type= 'character', required= FALSE, default= def, 
    choices= c('hg18', 'hg19', 'hg38', 'mm9', 'mm10'))

def_rnd<- 'The name of the input file'
parser$add_argument('--rnd-seed', '-s', help= sprintf('Seed for random number generator. Default: %s', def_rnd), type= 'character', default= def_rnd)

# NB: argparse v1.1.1+ required for -v option to work.
parser$add_argument("-v", "--version", action= 'version', version= VERSION)

xargs<- parser$parse_args()

# -----------------------------------------------------------------------------

suppressMessages(library(facets))
suppressMessages(library(data.table))
suppressMessages(library(Rsamtools))

exec_snp_pileup<- function(snp_vcf, output, normal_bam, tumour_bam, mapq, baq, pseudo_snp, min_read_norm, min_read_tum, max_depth){
    
    cmd<- c('snp-pileup',
            '--count-orphans',
            '--gzip',
            '--max-depth', max_depth,
            '--pseudo-snps', pseudo_snp,
            '--min-map-quality', mapq,
            '--min-base-quality', baq,
            '--min-read-counts', paste(c(min_read_norm, min_read_tum), collapse= ','),
            snp_vcf, output, normal_bam, tumour_bam
       )
    unlink(output)
    status<- system2(cmd)
    return(status)
}

readSnpMatrix2<- function(pileup){
    xf<- file(pileup, open= 'r')
    if(summary(xf)$class == 'gzfile'){
        conn<- sprintf('gunzip -c %s', pileup)
    } else {
        conn<- pileup
    }
    close(xf)
    rcmat<- fread(conn, select= c('Chromosome', 'Position', 'File1R', 'File1A', 'File2R', 'File2A'))
    setnames(rcmat, c('File1R', 'File1A', 'File2R', 'File2A'),
                    c('NOR.RD', 'NOR.DP', 'TUM.RD', 'TUM.DP'))
    rcmat[, NOR.DP := NOR.DP + NOR.RD]
    rcmat[, TUM.DP := TUM.DP + TUM.RD]
    rcmat[, Chromosome := sub("chr", "", Chromosome, fixed= TRUE)]
    setcolorder(rcmat, c('Chromosome', 'Position', 'NOR.DP', 'NOR.RD', 'TUM.DP', 'TUM.RD'))
    return(rcmat)
}

facetsRecordToVcf<- function(x){
    # Convert the annotated facets record to a VCF record.
    vcf<- vector(length= 8)
    vcf[1]<- x$chrom
    vcf[2]<- x$start+1 # TODO: Check +1 is correct
    vcf[3]<- x$seg
    vcf[4]<- 'N'
    vcf[5]<- '<CNV>'
    vcf[6]<- '.'
    vcf[7]<- ifelse(x$type == "NEUTR", 'neutral', 'PASS')

    # INFO field: Keep consistent with header
    vcf[8]<- paste0(
        'SVTYPE=', x$type,
        ';SVLEN=', x$end-x$start,
        ';END=', x$end,
        ';NUM_MARK=', x$num.mark,
        ';NHET=', x$nhet,
        ';CNLR_MEDIAN=', ifelse(is.na(x$cnlr.median), '.', round(x$cnlr.median, 3)), 
        ';MAF_R=', ifelse(is.na(x$mafR), '.', round(x$mafR, 3)), 
        ';SEGCLUST=', x$segclust, 
        ';CNLR_MEDIAN_CLUST=', ifelse(is.na(x$cnlr.median.clust), '.', round(x$cnlr.median.clust, 3)), 
        ';MAF_R_CLUST=', ifelse(is.na(x$mafR.clust), '.', round(x$mafR.clust, 3)), 
        ';CF_EM=', ifelse(is.na(x$cf.em), '.', round(x$cf.em, 3)),
        ';TCN_EM=', ifelse(is.na(x$tcn.em), '.', x$tcn.em),
        ';LCN_EM=', ifelse(is.na(x$lcn.em), '.', x$lcn.em))
   return(vcf)
}

getScriptName<- function(){
    opt<- grep('^--file=', commandArgs(trailingOnly = FALSE), value= TRUE)
    name<- basename(sub('^--file=', '', opt))
    return(name)
}

# ---------------- [Validate arguments] -------------

if(is.null(xargs$pileup) && (is.null(xargs$tumour) || is.null(xargs$normal))){
    write('Please provide a pileup file or both a tumour and a normal bam file', stderr()) 
    quit(status= 1)
}
if(is.null(xargs$pileup) && is.null(xargs$snp_vcf)){
    write('Please use the --snp_vcf option to provide a VCF file of SNPs', stderr()) 
    quit(status= 1)
}
if(xargs$depth[1] > xargs$depth[2]){
    write('Error in argument --depth: min > max', stderr()) 
    quit(status= 1)
}
if(xargs$cval[1] > xargs$cval[2]){
    write('Error in argument --cval. Value for pre-processing (first argument)\nmust be lower than the value for processing (second argument)', stderr()) 
    quit(status= 1)
}
# --------------- [Start processing] ----------------

dir.create(dirname(xargs$out), recursive= TRUE, showWarnings= FALSE)

if(xargs$rnd_seed == def_rnd){
    if( ! is.null(xargs$pileup) ){
        seed<- sum(utf8ToInt(xargs$pileup))
    } else {
        seed<- sum(utf8ToInt(paste(xargs$normal, xargs$tumour)))
    }
} else if( ! is.na(suppressWarnings(as.numeric(xargs$rnd_seed)))){
    seed<- as.numeric(xargs$rnd_seed)
} else {
    seed<- sum(utf8ToInt(xargs$rnd_seed))
}
set.seed(seed)

if(is.null(xargs$pileup)){
    pileup<- paste0(xargs$out, '.csv.gz')
    status<- exec_snp_pileup(snp_vcf= xargs$snp_vcf, 
                             output= pileup, 
                             normal_bam= xargs$normal, 
                             tumour_bam= xargs$tumour, 
                             mapq= xargs$snp_mapq, 
                             baq= xargs$snp_baq, 
                             pseudo_snp= xargs$snp_pseudo,
                             min_read_norm= xargs$snp_min_read_norm,
                             min_read_tum= xargs$snp_min_read_tum,
                             max_depth= xargs$depth[2]
                             )
} else {
    pileup<- xargs$pileup
}

write(sprintf('Loading file %s...', pileup), stderr())
rcmat<- readSnpMatrix2(pileup)

# ------------- [Run FACETS] --------------

write(sprintf('Preprocessing sample...'), stderr())
xx<- preProcSample(rcmat, ndepth= xargs$depth[1], gbuild= xargs$gbuild, snp.nbhd= xargs$nbhd_snp, het.thresh= 0.25, cval= xargs$cval[1], deltaCN= 0, unmatched= FALSE, ndepthmax= xargs$depth[2])
rm(rcmat)
x_ <- gc(verbose= FALSE)

write(sprintf('Processing sample...'), stderr())
oo<- procSample(xx, cval= xargs$cval[2], min.nhet= 15, dipLogR= NULL)

write(sprintf('Fitting model...'), stderr())
fit<- emcncf(oo, unif= FALSE, min.nhet= 15, maxiter= 20, eps=1e-3)

# -----------------------------------------

write(sprintf('Writing output'), stderr())
out<- data.table(fit$cncf)
stopifnot(all(!grepl('chr', out$chrom)))
out[, chrom := paste0('chr', chrom)]
out[, chrom := sub('chr23', 'chrX', chrom)] # This is because of bug https://github.com/mskcc/facets/issues/60
setcolorder(out, c('chrom', 'start', 'end', 'seg', 'num.mark', 'nhet', 'cnlr.median', 'mafR', 'segclust', 'cnlr.median.clust', 'mafR.clust', 'cf.em', 'tcn.em', 'lcn.em'))

# Classify CNV. See also https://github.com/mskcc/facets/issues/62
out[, type := NA]
out[, type := ifelse((tcn.em == 2 & (lcn.em == 1 | is.na(lcn.em))), 'NEUTR', type)]
out[, type := ifelse(is.na(type) & tcn.em == 0, 'DEL', type)]
out[, type := ifelse(is.na(type) & tcn.em > 2 & (lcn.em > 0 | is.na(lcn.em)), 'DUP', type)]
out[, type := ifelse(is.na(type) & tcn.em == 1, 'HEMIZYG', type)]
out[, type := ifelse(is.na(type) & tcn.em == 2 & lcn.em == 0, 'LOH', type)]
out[, type := ifelse(is.na(type) & tcn.em > 2 & lcn.em == 0, 'DUP-LOH', type)]
out<- out[order(chrom, start)]
stopifnot(all(!is.na(out$type))) # Everything has been classified

vcf_tmp<- tempfile(pattern= paste0(basename(xargs$out), '.'), tmpdir= dirname(xargs$out), fileext= '.vcf')

write('##fileformat=VCFv4.2', vcf_tmp, append= FALSE)
write('##FILTER=<ID=PASS,Description="All filters passed">', vcf_tmp, append= TRUE)
write(sprintf('##%sCommand=%s; Version=%s; Date=%s', getScriptName(), paste(commandArgs(), collapse= ' '), VERSION, Sys.time()), vcf_tmp, append= TRUE)

if( ! is.null(xargs$fai) ){
    fai<- fread(xargs$fai)
    for(i in 1:nrow(fai)){
        write(sprintf('##contig=<ID=%s,length=%s>', fai[i]$V1, fai[i]$V2), vcf_tmp, append= TRUE)
    }
} else if ( ! is.null(xargs$tumour) ){
    targets<- scanBamHeader(xargs$tumour)[[1]]$targets
    targets<- data.table(V1= names(targets), V2= targets)
    for(i in 1:nrow(targets)){
        write(sprintf('##contig=<ID=%s,length=%s>', targets[i]$V1, targets[i]$V2), vcf_tmp, append= TRUE)
    }
} else {
    for(chrom in unique(out$chrom)){
        write(sprintf('##contig=<ID=%s>', chrom), vcf_tmp, append= TRUE)
    }
}

write('##FILTER=<ID=PASS,Description="All filters passed">', vcf_tmp, append= TRUE)
write('##FILTER=<ID=neutral,Description="Copy number neutral">', vcf_tmp, append= TRUE)
write('##INFO=<ID=SVTYPE,Number=1,Type=String,Description="Type of structural variant">', vcf_tmp, append= TRUE)
write('##INFO=<ID=SVLEN,Number=1,Type=Integer,Description="Difference in length between REF and ALT alleles">', vcf_tmp, append= TRUE)
write('##INFO=<ID=END,Number=1,Type=Integer,Description="End position of the variant described in this record">', vcf_tmp, append= TRUE)
write('##INFO=<ID=NUM_MARK,Number=1,Type=Integer,Description="Number of SNPs in the segment">', vcf_tmp, append= TRUE)
write('##INFO=<ID=NHET,Number=1,Type=Integer,Description="Number of SNPs that are deemed heterozygous">', vcf_tmp, append= TRUE)
write('##INFO=<ID=CNLR_MEDIAN,Number=1,Type=Float,Description="Median log-ratio (logR) of the segment. logR is defined by the log-ratio of total read depth in the tumor versus that in the normal">', vcf_tmp, append= TRUE)
write('##INFO=<ID=CNLR_MEDIAN_CLUST,Number=1,Type=Float,Description="Median log-ratio (logR) of the segment cluster. logR is defined by the log-ratio of total read depth in the tumor versus that in the normal">', vcf_tmp, append= TRUE)
write('##INFO=<ID=MAF_R,Number=1,Type=Float,Description="Log-odds-ratio (logOR) summary for the segment. logOR is defined by the log-odds ratio of the variant allele count in the tumor versus in the normal">', vcf_tmp, append= TRUE)
write('##INFO=<ID=MAF_R_CLUST,Number=1,Type=Float,Description="Log-odds-ratio (logOR) summary for the segment cluster. logOR is defined by the log-odds ratio of the variant allele count in the tumor versus that in the normal">', vcf_tmp, append= TRUE)
write('##INFO=<ID=SEGCLUST,Number=1,Type=Integer,Description="Segment cluster to which the segment belongs">', vcf_tmp, append= TRUE)
write('##INFO=<ID=CF_EM,Number=1,Type=Float,Description="Cellular fraction, fraction of DNA associated with the aberrant genotype. Set to 1 for normal diploid">', vcf_tmp, append= TRUE)
write('##INFO=<ID=TCN_EM,Number=1,Type=Integer,Description="Total copy number. 2 for normal diploid">', vcf_tmp, append= TRUE)
write('##INFO=<ID=LCN_EM,Number=1,Type=Integer,Description="Lesser (minor) copy number. 1 for normal diploid">', vcf_tmp, append= TRUE)

write(paste0('##purity=', fit$purity), vcf_tmp, append= TRUE)
write(paste0('##ploidy=', fit$ploidy), vcf_tmp, append= TRUE)
write(paste0('##dipLogR=', fit$dipLogR), vcf_tmp, append= TRUE)
write(paste0('##emflags="', fit$emflags, '"'), vcf_tmp, append= TRUE)

write('#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO', vcf_tmp, append= TRUE)
for(i in 1:nrow(out)){
    write(paste(facetsRecordToVcf(out[i]), collapse= '\t'), vcf_tmp, append= TRUE)
}

x_<- bgzip(vcf_tmp, dest= paste0(xargs$out, '.vcf.gz'), overwrite= TRUE)
x_<- indexTabix(paste0(xargs$out, '.vcf.gz'), format= 'vcf4')
unlink(vcf_tmp)

write(sprintf('Plotting genome...'), stderr())
png(paste0(xargs$out, '.cnv.png'), units="px", width=1600, height=1600, res=300)
sname<- sprintf('%s; ploidy= %.2f; purity= %.2f', basename(xargs$out), fit$ploidy, fit$purity)
plotSample(x=oo, emfit=fit, sname= sname)
x_ <- dev.off()

write(sprintf('Plotting spider...'), stderr())
pdf(paste0(xargs$out, '.spider.pdf'), width= 16/2.54, height= 14/2.54)
par(las= 1, mar= c(3, 3, 1, 1), mgp= c(1.5, 0.5, 0), tcl= -0.3)
logRlogORspider(oo$out, oo$dipLogR)
x_ <- dev.off()

si<- capture.output(sessionInfo())
write(si, stderr())
