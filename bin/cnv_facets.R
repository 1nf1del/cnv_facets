#!/usr/bin/env Rscript
#
# Copyright (C) 2018 University of Glasgow
#
# Author: Dario Beraldi <dario.beraldi@glasgow.ac.uk>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.

suppressMessages(library(argparse))

# -----------------------------------------------------------------------------

VERSION= sprintf('0.8.0; facets %s', packageVersion('facets'))

docstring<- sprintf('DESCRIPTION \\n\\
Detect copy number variants (CNVs) and estimate purity and ploidy in a tumour\\n\\
sample givn a tumour-normal pair. The analysis is based on the facets method\\n\\
(https://github.com/mskcc/facets).\\n\\
\\n\\
Input:\\n\\
\\n\\
* A bam file for the tumour sample, a bam file for the matched normal sample, and a vcf\\n\\
  file of SNP positions. IMPORTANT: bam and vcf files must be coordinate sorted\\n\\
  with chrosomome order being the same across all three files (there is no\\n\\
  check for this)\\n\\
\\n\\
Or:\\n\\
\\n\\
* A csv file of counts generated by a previous run of cnv_facets.R or by the\\n\\
  accompanying program snp-pileup\\n\\
\\n\\
See the online documentation for more details and usage.\\n\\
Version %s', VERSION)

parser<- ArgumentParser(description= docstring, formatter_class= 'argparse.RawTextHelpFormatter')

parser$add_argument('--out', '-o', help= 'Output prefix for the output files', required= TRUE)

parser$add_argument('--snp-tumour', '-t', help= 'BAM file for tumour sample. Ignored if using --pileup', required= FALSE)
parser$add_argument('--snp-normal', '-n', help= 'BAM file for normal sample. Ignored if using --pileup', required= FALSE)

parser$add_argument('--snp-vcf', '-vcf', help= 'VCF file of SNPs where pileup is to be computed. Ignored if using --pileup required otherwise', required= FALSE)

def<- 100
parser$add_argument('--snp-pseudo', '-P', help= sprintf('If there is no SNP every MULTIPLE positions, insert a blank \\n\\
record with the total count at that position. Ignored if using --pileup. Default %s', def), 
                    required= FALSE, default= def, type= 'integer')

def<- 0
parser$add_argument('--snp-mapq', '-mq', help= sprintf('Sets the minimum threshold for mapping quality. Ignored if using --pileup. Default %s', def), required= FALSE, default= def, type= 'integer')

def<- 0
parser$add_argument('--snp-baq', '-bq', help= sprintf('Sets the minimum threshold for base quality. Ignored if using --pileup. Default %s', def), required= FALSE, default= def, type= 'integer')

def<- 0
parser$add_argument('--snp-min-read-norm', '-rn', help= sprintf('Minimum read count in normal bam for a position to be output. Ignored if using --pileup. Default %s', def), required= FALSE, default= def, type= 'integer')

def<- 0
parser$add_argument('--snp-min-read-tum', '-rt', help= sprintf('Minimum read count in tumour bam for a position to be output. Ignored if using --pileup. Default %s', def), required= FALSE, default= def, type= 'integer')

def<- 1
parser$add_argument('--snp-nprocs', '-N', help= sprintf('Number of parallel processes to run to prepare the read pileup file.\\n\\
Each chromsome is assigned to a process. Ignored if using --pileup. Default %s', def), required= FALSE, default= def, type= 'integer')

parser$add_argument('--pileup', '-p', help= 'Pileup for matched normal (first sample) and tumour (second sample). \\n\\
This is the output of the snp-pileup program accompanying facets.', required= FALSE)

def<- c(25, 4000)
parser$add_argument('--depth', '-d', help= sprintf('Minimum and maximum depth in normal sample for a position to be considered. Default %s', paste(def, collapse= ' ')), type= 'integer', default= def, nargs= 2)

def<- c(25, 150)
parser$add_argument('--cval', '-cv', help= sprintf("Critical values for segmentation in pre-processing and processing.\\n\\
Larger values reduce segmentation. [25 150] is facets default based on exome data. For whole genome\\n\\
consider increasing to [25 400] and for targeted sequencing consider reducing them. Default %s", paste(def, collapse= ' ')), type= 'double', default= def, nargs= 2)

def<- 250 
parser$add_argument('--nbhd-snp', '-snp', help= sprintf('If an interval of size nbhd-snp contains more than one SNP, sample a random one.\\n\\
This sampling reduces the SNP serial correlation. This value should be similar\\n\\
to the median insert size of the libraries. 250 is facets default based on\\n\\
exome data. For whole genome consider increasing to 500 and for target\\n\\
sequencing decrease to 150. Default %s', def), type= 'integer', default= def)

parser$add_argument('--annotation', '-a', help= sprintf('Optional annotation file in BED format where the 4th column contains the\\n\\
feature name (e.g. gene name). CNVs will be annotated with an additional \\n\\
INFO/TAG reporting all the overalapping features'), type= 'character', required= FALSE)

def<- 'hg38'
parser$add_argument('--gbuild', '-g', help= sprintf('String indicating the reference genome build. Default %s.', def), 
    type= 'character', required= FALSE, default= def, 
    choices= c('hg19', 'hg38', 'mm9', 'mm10'))

def_rnd<- 'The name of the input file'
parser$add_argument('--rnd-seed', '-s', help= sprintf('Seed for random number generator. Default: %s', def_rnd), type= 'character', default= def_rnd)

# NB: argparse v1.1.1+ required for -v option to work.
parser$add_argument("-v", "--version", action= 'version', version= VERSION)

xargs<- parser$parse_args()

# -----------------------------------------------------------------------------
HG19<- c(chr1= 249250621, 
         chr2= 243199373, 
         chr3= 198022430, 
         chr4= 191154276, 
         chr5= 180915260, 
         chr6= 171115067, 
         chr7= 159138663, 
         chr8= 146364022, 
         chr9= 141213431, 
         chr10= 135534747, 
         chr11= 135006516, 
         chr12= 133851895, 
         chr13= 115169878, 
         chr14= 107349540, 
         chr15= 102531392, 
         chr16= 90354753, 
         chr17= 81195210, 
         chr18= 78077248, 
         chr19= 59128983, 
         chr20= 63025520,  
         chr21= 48129895, 
         chr22= 51304566, 
         chrM= 16571, 
         chrX= 155270560, 
         chrY= 59373566)

HG38<- c(chr1= 248956422,
         chr2= 242193529,
         chr3= 198295559,
         chr4= 190214555,
         chr5= 181538259,
         chr6= 170805979,
         chr7= 159345973,
         chr8= 145138636,
         chr9= 138394717,
         chr11= 135086622,
         chr10= 133797422,
         chr12= 133275309,
         chr13= 114364328,
         chr14= 107043718,
         chr15= 101991189,
         chr16= 90338345,
         chr17= 83257441,
         chr18= 80373285,
         chr19= 58617616,
         chr20= 64444167,
         chr21= 46709983,
         chr22= 50818468,
         chrM=  16569,
         chrX= 156040895,
         chrY= 57227415)

MM9<- c(chr1= 197195432,
        chr2= 181748087,
        chr3= 159599783,
        chr4= 155630120,
        chr5= 152537259,
        chr6= 149517037,
        chr7= 152524553,
        chr8= 131738871,
        chr9= 124076172,
        chr10= 129993255,
        chr11= 121843856,
        chr12= 121257530,
        chr13= 120284312,
        chr14= 125194864,
        chr15= 103494974,
        chr16= 98319150,
        chr17= 95272651,
        chr18= 90772031,
        chr19= 61342430,
        chrM= 16299,
        chrX= 166650296,
        chrY= 15902555)

MM10<- c(chr1= 195471971,
         chr2= 182113224,
         chr3= 160039680,
         chr4= 156508116,
         chr5= 151834684,
         chr6= 149736546,
         chr7= 145441459,
         chr8= 129401213,
         chr9= 124595110,
         chr10= 130694993,
         chr11= 122082543,
         chr12= 120129022,
         chr13= 120421639,
         chr14= 124902244,
         chr15= 104043685,
         chr16= 98207768,
         chr17= 94987271,
         chr18= 90702639,
         chr19= 61431566,
         chrM= 16299,
         chrX= 171031299,
         chrY= 91744698)

# -----------------------------------------------------------------------------

suppressMessages(library(facets))
suppressMessages(library(data.table))
suppressMessages(library(Rsamtools))

exec_snp_pileup<- function(chrom, snp_vcf, output, normal_bam, tumour_bam, mapq, baq, pseudo_snp, min_read_norm, min_read_tum, max_depth){
    # Execute snp-pileup on chromosome `chrom` 
    
    # Send tmp output to the same directory of the final output so we are sure
    # we can write there.
    d<- dirname(output)
    chrom_vcf<- file.path(d, paste0(sub('\\.vcf\\.gz$|\\.vcf\\.bgz$', '', basename(snp_vcf)), '.', chrom, '.vcf'))
    chrom_nbam<- file.path(d, paste0(sub('\\.bam', '', basename(normal_bam)), '.', chrom, '.bam'))
    chrom_tbam<- file.path(d, paste0(sub('\\.bam', '', basename(tumour_bam)), '.', chrom, '.bam'))

    cmd<- c('set -e', '\n',
            'mkfifo', chrom_vcf, '\n',
            'mkfifo', chrom_nbam, '\n',
            'mkfifo', chrom_tbam, '\n',
            'bcftools view --output-type u', snp_vcf, chrom, '>', chrom_vcf, '&\n',
            'samtools view -u', normal_bam, chrom, '>', chrom_nbam, '&\n',
            'samtools view -u', tumour_bam, chrom, '>', chrom_tbam, '&\n',
            'snp-pileup',
            # '--count-orphans',
            '--gzip',
            '--max-depth', max_depth,
            '--pseudo-snps', pseudo_snp,
            '--min-map-quality', mapq,
            '--min-base-quality', baq,
            '--min-read-counts', paste(c(min_read_norm, min_read_tum), collapse= ','),
            chrom_vcf, output, chrom_nbam, chrom_tbam
       )
    cmd<- paste(cmd, collapse= ' ')
    status<- system(cmd)
    if(status != 0){
        stop(sprintf('\nError in computing snp pileup. Exit code %s for command \n%s\n\n' , status, cmd))
    }
    unlink(c(chrom_vcf, chrom_nbam, chrom_tbam))
    return(cmd)
}

exec_snp_pileup_parallel<- function(snp_vcf, output, normal_bam, tumour_bam, mapq, baq, pseudo_snp, min_read_norm, min_read_tum, max_depth, nprocs){
    
    dtm<- format(Sys.time(), "%y%m%d-%H%M%S")
    tmpdir<- tempfile(pattern = paste0('cnv_', dtm, '_'), tmpdir = dirname(output))
    dir.create(tmpdir)
    
    chroms<- headerTabix(snp_vcf)$seqnames

    cl<- makeCluster(nprocs, type= 'FORK')
    chrom_csv<- parLapply(cl, chroms, function(chrom){
        chrom_csv<- file.path(tmpdir, paste0(chrom, '.csv.gz'))
        cmd<- exec_snp_pileup(chrom= chrom, 
                              snp_vcf= snp_vcf,
                              output= chrom_csv, 
                              normal_bam= normal_bam, 
                              tumour_bam= tumour_bam, 
                              mapq= mapq, 
                              baq= baq, 
                              pseudo_snp= pseudo_snp, 
                              min_read_norm= min_read_norm, 
                              min_read_tum= min_read_tum, 
                              max_depth= max_depth)
        return(chrom_csv)
    })
    stopCluster(cl)
    concat_csv(chrom_csv, output, tmpdir= tmpdir)
    unlink(tmpdir, recursive= TRUE)
}

# split_vcf<- function(vcf, outdir){
#     write(sprintf('Splitting vcf file %s into %s', vcf, outdir), stderr())
#     xf<- file(vcf, open= 'r')
#     if(summary(xf)$class == 'gzfile'){
#         conn<- sprintf('gzip -d -c %s', vcf)
#     } else {
#         conn<- vcf
#     }
#     close(xf)
#     
#     options(datatable.fread.input.cmd.message= FALSE)
#     snp<- fread(conn, select= c('#CHROM', 'POS', 'ID', 'REF', 'ALT'))
#     options(datatable.fread.input.cmd.message= TRUE)
# 
#     chroms<- unique(snp[['#CHROM']])
#     chrom_output<- vector()
#     for(chrom in chroms){
#         out<- file.path(outdir, paste0(chrom, '.vcf'))
#         chrom_output<- c(chrom_output, out)
#         snp_out<- snp[snp[['#CHROM']] == chrom]
#         snp_out[, QUAL := '.']
#         snp_out[, FILTER := '.']
#         write('##fileformat=VCFv4.0', out) # Minimal meta-data!
#         options(warn= -1) # Ignore the warning about appending column names
#         if(grepl('data.table', find('fwrite', mode= 'function'))){
#             fwrite(snp_out, file= out, append= TRUE, sep= '\t', quote= FALSE, row.names= FALSE, col.names= TRUE)
#         } else {
#             write.table(snp_out, file= out, append= TRUE, sep= '\t', quote= FALSE, row.names= FALSE, col.names= TRUE)
#         }
#         options(warn= 0)
#         rm(snp_out)
#     }
#     rm(snp)
#     for(i in 1:10){
#         x_ <- gc(verbose= FALSE)
#     }
#     return(chrom_output)
# }

concat_csv<- function(csv_list, xfile, tmpdir){
    isGzip<- ifelse(grepl('\\.gz$', xfile), TRUE, FALSE)
    if(isGzip == TRUE){
        conn<- file.path(tmpdir, sub('\\.gz', '', basename(xfile))) # tempfile(pattern= 'cnv_facets_', tmpdir= dirname(xfile), fileext= '.csv')
    } else {
        conn<- xfile
    }
    col.names<- TRUE
    for(csv in csv_list){
        options(datatable.fread.input.cmd.message= FALSE)
        fwrite(x= fread(sprintf('gzip -d -c %s', csv)), file= conn, sep= ',', col.names= col.names, row.name= FALSE, quote= FALSE, append= isFALSE(col.names))
        options(datatable.fread.input.cmd.message= TRUE)
        col.names<- FALSE
    }
    if(isGzip == TRUE){
        system2(c('gzip', '-c', conn), stdout= xfile)
        unlink(conn)
    }
}

readSnpMatrix2<- function(pileup, gbuild){
    xf<- file(pileup, open= 'r')
    if(summary(xf)$class == 'gzfile'){
        conn<- sprintf('gzip -d -c %s', pileup)
    } else {
        conn<- pileup
    }
    close(xf)
    
    options(datatable.fread.input.cmd.message= FALSE)
    rcmat<- fread(conn, select= c('Chromosome', 'Position', 'File1R', 'File1A', 'File2R', 'File2A'))
    options(datatable.fread.input.cmd.message= TRUE)

    setnames(rcmat, c('File1R', 'File1A', 'File2R', 'File2A'),
                    c('NOR.RD', 'NOR.DP', 'TUM.RD', 'TUM.DP'))
    rcmat[, NOR.DP := NOR.DP + NOR.RD]
    rcmat[, TUM.DP := TUM.DP + TUM.RD]

    chr_prefix<- any(rcmat$Chromosome %in% c(paste0('chr', 1:22), 'chrX'))

    # Unfortunately, facets needs numeric chromsomes. X will be converted later by facets
    rcmat[, Chromosome := sub("^chr", "", Chromosome)]
    setcolorder(rcmat, c('Chromosome', 'Position', 'NOR.DP', 'NOR.RD', 'TUM.DP', 'TUM.RD'))

    # We only keep the major chromosomes 
    if(gbuild %in% c("hg19", "hg38")){
        rcmat<- rcmat[Chromosome %in% c(1:22, 'X')]
    } else if(gbuild %in% c("mm9", "mm10")){
        rcmat<- rcmat[Chromosome %in% c(1:19, 'X')]
    } else {
        write(sprintf('Invalid genome build: %s', gbuild), stderr())
        quit(status= 1)
    }
    return(list(pileup= rcmat, chr_prefix= chr_prefix))
}

facetsRecordToVcf<- function(x){
    # Convert the annotated facets record to a VCF record.
    vcf<- vector(length= 8)
    vcf[1]<- x$chrom
    vcf[2]<- x$start+1 # TODO: Check +1 is correct
    vcf[3]<- x$seg
    vcf[4]<- 'N'
    vcf[5]<- '<CNV>'
    vcf[6]<- '.'
    vcf[7]<- ifelse(x$type == "NEUTR", 'neutral', 'PASS')

    # INFO field: Keep consistent with header
    vcf[8]<- paste0(
        'SVTYPE=', x$type,
        ';SVLEN=', x$end-x$start,
        ';END=', x$end,
        ';NUM_MARK=', x$num.mark,
        ';NHET=', x$nhet,
        ';CNLR_MEDIAN=', ifelse(is.na(x$cnlr.median), '.', round(x$cnlr.median, 3)), 
        ';MAF_R=', ifelse(is.na(x$mafR), '.', round(x$mafR, 3)), 
        ';SEGCLUST=', x$segclust, 
        ';CNLR_MEDIAN_CLUST=', ifelse(is.na(x$cnlr.median.clust), '.', round(x$cnlr.median.clust, 3)), 
        ';MAF_R_CLUST=', ifelse(is.na(x$mafR.clust), '.', round(x$mafR.clust, 3)), 
        ';CF_EM=', ifelse(is.na(x$cf.em), '.', round(x$cf.em, 3)),
        ';TCN_EM=', ifelse(is.na(x$tcn.em), '.', x$tcn.em),
        ';LCN_EM=', ifelse(is.na(x$lcn.em), '.', x$lcn.em),
        ';CNV_ANN=', ifelse(is.na(x$annotation) || is.null(x$annotation) || x$annotation == '', '.', x$annotation))
    return(vcf)
}

getScriptName<- function(){
    opt<- grep('^--file=', commandArgs(trailingOnly = FALSE), value= TRUE)
    name<- basename(sub('^--file=', '', opt))
    return(name)
}

annotate<- function(cnv, bed_file){
    # Annotate data.table cnv with the features in bed_file

    ann<- data.table(read.table(bed_file, comment.char= '#', header= FALSE, sep= '\t', stringsAsFactors= FALSE, na.strings= ""))
    stopifnot(ncol(ann) >= 4)
    ann<- ann[, 1:4]
    setnames(ann, names(ann), c('chrom', 'start', 'end', 'name'))
    ann<- ann[!is.na(name)]

    # Make feature names VCF compliant. From https://samtools.github.io/hts-specs/VCFv4.1.pdf:
    #
    #     String, no white-space, semi-colons, or equals-signs permitted; commas are
    #     permitted only as delimiters for lists of values
    #
    # Convert special characters using URL encoding
    ann[, name := gsub('%', '%25', name, fixed= TRUE)]
    ann[, name := gsub(',', '%2C', name, fixed= TRUE)]
    ann[, name := gsub('=', '%3D', name, fixed= TRUE)]
    ann[, name := gsub(';', '%3B', name, fixed= TRUE)]
    ann[, name := gsub('|', '%7C', name, fixed= TRUE)]
    ann[, name := gsub(' ', '_', name, fixed= TRUE)] # NB: Not URL encoding for spaces!

    ann<- makeGRangesFromDataFrame(ann, seqnames.field= 'chrom', start.field= 'start', end.field= 'end', keep.extra.columns= TRUE)

    gcnv<- makeGRangesFromDataFrame(cnv, seqnames.field= 'chrom', start.field= 'start', end.field= 'end', keep.extra.columns= TRUE)
    ovl<- findOverlaps(query= gcnv, subject= ann, ignore.strand= TRUE)

    hits<- data.table(queryHits= ovl@from, subjectHits= ovl@to, feature= ann$name[ovl@to])
    hits<- hits[, list(feature= paste(feature,  collapse= ',')), by= queryHits]
    gcnv<- as.data.table(gcnv)
    gcnv[, annotation := NA]
    gcnv$annotation[hits$queryHits]<- hits$feature
    gcnv$annotation[gcnv$type == 'NEUTR']<- NA
    setnames(gcnv, 'seqnames', 'chrom')
    gcnv[, chrom := as.character(chrom)]

    stopifnot(cnv$chrom == gcnv$chrom)
    stopifnot(cnv$start == gcnv$start)
    stopifnot(cnv$end == gcnv$end)
    return(gcnv)
}

# ---------------- [Validate arguments] -------------

if(is.null(xargs$pileup) && (is.null(xargs$snp_tumour) || is.null(xargs$snp_normal))){
    write('Please provide a pileup file or both a tumour and a normal bam file', stderr()) 
    quit(status= 1)
}
if(! is.null(xargs$snp_tumour) && xargs$snp_tumour == xargs$snp_normal){
    write('Input bam files for tumour and normal cannot be the same', stderr())
    quit(status= 1)
}

if(is.null(xargs$pileup) && is.null(xargs$snp_vcf)){
    write('Please use the --snp_vcf option to provide a VCF file of SNPs', stderr()) 
    quit(status= 1)
}
if(xargs$depth[1] > xargs$depth[2]){
    write('Error in argument --depth: min > max', stderr()) 
    quit(status= 1)
}
if(xargs$cval[1] > xargs$cval[2]){
    write('Error in argument --cval. Value for pre-processing (first argument)\nmust be lower than the value for processing (second argument)', stderr()) 
    quit(status= 1)
}
# --------------- [Start processing] ----------------

dir.create(dirname(xargs$out), recursive= TRUE, showWarnings= FALSE)

if(xargs$rnd_seed == def_rnd){
    if( ! is.null(xargs$pileup) ){
        seed<- sum(utf8ToInt(xargs$pileup))
    } else {
        seed<- sum(utf8ToInt(paste(xargs$snp_normal, xargs$snp_tumour)))
    }
} else if( ! is.na(suppressWarnings(as.numeric(xargs$rnd_seed)))){
    seed<- as.numeric(xargs$rnd_seed)
} else {
    seed<- sum(utf8ToInt(xargs$rnd_seed))
}
set.seed(seed)

if(is.null(xargs$pileup)){
    pileup<- paste0(xargs$out, '.csv.gz')
    basename(xargs$snp_tumour)
    exec_snp_pileup_parallel(snp_vcf= xargs$snp_vcf, 
                             output= pileup, 
                             normal_bam= xargs$snp_normal, 
                             tumour_bam= xargs$snp_tumour, 
                             mapq= xargs$snp_mapq, 
                             baq= xargs$snp_baq, 
                             pseudo_snp= xargs$snp_pseudo,
                             min_read_norm= xargs$snp_min_read_norm,
                             min_read_tum= xargs$snp_min_read_tum,
                             max_depth= xargs$depth[2],
                             nprocs= xargs$snp_nprocs
                             )
} else {
    pileup<- xargs$pileup
}

write(sprintf('Loading file %s...', pileup), stderr())
rcmat<- readSnpMatrix2(pileup, xargs$gbuild)

# ------------- [Run FACETS] --------------

write(sprintf('Preprocessing sample...'), stderr())
xx<- preProcSample(rcmat[['pileup']], ndepth= xargs$depth[1], gbuild= xargs$gbuild, snp.nbhd= xargs$nbhd_snp, het.thresh= 0.25, cval= xargs$cval[1], deltaCN= 0, unmatched= FALSE, ndepthmax= xargs$depth[2])
rcmat[['pileup']]<- NULL
x_ <- gc(verbose= FALSE)

write(sprintf('Processing sample...'), stderr())
oo<- procSample(xx, cval= xargs$cval[2], min.nhet= 15, dipLogR= NULL)

write(sprintf('Fitting model...'), stderr())
fit<- emcncf(oo, unif= FALSE, min.nhet= 15, maxiter= 20, eps=1e-3)

# -----------------------------------------

write(sprintf('Writing output'), stderr())
out<- data.table(fit$cncf)

# Reset chrom X
if(xargs$gbuild %in% c('hg19', 'hg38')){
    out[, chrom := ifelse(chrom == 23, 'X', chrom)]
} else if(xargs$gbuild %in% c('mm9', 'mm10')){
    out[, chrom := ifelse(chrom == 20, 'X', chrom)]
} else {
    quit(status= 1)
}
# Reset chrom names
if(rcmat$chr_prefix == TRUE){
    out[, chrom := paste0('chr', chrom)]
}
setcolorder(out, c('chrom', 'start', 'end', 'seg', 'num.mark', 'nhet', 'cnlr.median', 'mafR', 'segclust', 'cnlr.median.clust', 'mafR.clust', 'cf.em', 'tcn.em', 'lcn.em'))

# Classify CNV. See also https://github.com/mskcc/facets/issues/62
out[, type := NA]
out[, type := ifelse((tcn.em == 2 & (lcn.em == 1 | is.na(lcn.em))), 'NEUTR', type)]
out[, type := ifelse(is.na(type) & tcn.em == 0, 'DEL', type)]
out[, type := ifelse(is.na(type) & tcn.em > 2 & (lcn.em > 0 | is.na(lcn.em)), 'DUP', type)]
out[, type := ifelse(is.na(type) & tcn.em == 1, 'HEMIZYG', type)]
out[, type := ifelse(is.na(type) & tcn.em == 2 & lcn.em == 0, 'LOH', type)]
out[, type := ifelse(is.na(type) & tcn.em > 2 & lcn.em == 0, 'DUP-LOH', type)]
out<- out[order(chrom, start)]
stopifnot(all(!is.na(out$type))) # Everything has been classified

if(is.null(xargs$annotation) == FALSE){
    out<- annotate(out, xargs$annotation)
}

vcf_tmp<- tempfile(pattern= paste0(basename(xargs$out), '.'), tmpdir= dirname(xargs$out), fileext= '.vcf')

write('##fileformat=VCFv4.2', vcf_tmp, append= FALSE)
write(sprintf('##reference=%s', xargs$gbuild), vcf_tmp, append= TRUE)
write('##FILTER=<ID=PASS,Description="All filters passed">', vcf_tmp, append= TRUE)

# Write contigs to header
# --------------------------
if(xargs$gbuild == 'hg19') {chrom_size<- HG19}
if(xargs$gbuild == 'hg38') {chrom_size<- HG38}
if(xargs$gbuild == 'mm9') {chrom_size<- MM9}
if(xargs$gbuild == 'mm10') {chrom_size<- MM10}

for(i in 1:length(chrom_size)){
    size<- chrom_size[i]
    name<- names(size)
    if(rcmat$chr_prefix != TRUE){
        name<- sub('^chr', '', name)
    }
    write(sprintf('##contig=<ID=%s,length=%s>', name, size), vcf_tmp, append= TRUE)
}
# --------------------------

write('##FILTER=<ID=PASS,Description="All filters passed">', vcf_tmp, append= TRUE)
write('##FILTER=<ID=neutral,Description="Copy number neutral">', vcf_tmp, append= TRUE)
write('##INFO=<ID=SVTYPE,Number=1,Type=String,Description="Type of structural variant">', vcf_tmp, append= TRUE)
write('##INFO=<ID=SVLEN,Number=1,Type=Integer,Description="Difference in length between REF and ALT alleles">', vcf_tmp, append= TRUE)
write('##INFO=<ID=END,Number=1,Type=Integer,Description="End position of the variant described in this record">', vcf_tmp, append= TRUE)
write('##INFO=<ID=NUM_MARK,Number=1,Type=Integer,Description="Number of SNPs in the segment">', vcf_tmp, append= TRUE)
write('##INFO=<ID=NHET,Number=1,Type=Integer,Description="Number of SNPs that are deemed heterozygous">', vcf_tmp, append= TRUE)
write('##INFO=<ID=CNLR_MEDIAN,Number=1,Type=Float,Description="Median log-ratio (logR) of the segment. logR is defined by the log-ratio of total read depth in the tumor versus that in the normal">', vcf_tmp, append= TRUE)
write('##INFO=<ID=CNLR_MEDIAN_CLUST,Number=1,Type=Float,Description="Median log-ratio (logR) of the segment cluster. logR is defined by the log-ratio of total read depth in the tumor versus that in the normal">', vcf_tmp, append= TRUE)
write('##INFO=<ID=MAF_R,Number=1,Type=Float,Description="Log-odds-ratio (logOR) summary for the segment. logOR is defined by the log-odds ratio of the variant allele count in the tumor versus in the normal">', vcf_tmp, append= TRUE)
write('##INFO=<ID=MAF_R_CLUST,Number=1,Type=Float,Description="Log-odds-ratio (logOR) summary for the segment cluster. logOR is defined by the log-odds ratio of the variant allele count in the tumor versus that in the normal">', vcf_tmp, append= TRUE)
write('##INFO=<ID=SEGCLUST,Number=1,Type=Integer,Description="Segment cluster to which the segment belongs">', vcf_tmp, append= TRUE)
write('##INFO=<ID=CF_EM,Number=1,Type=Float,Description="Cellular fraction, fraction of DNA associated with the aberrant genotype. Set to 1 for normal diploid">', vcf_tmp, append= TRUE)
write('##INFO=<ID=TCN_EM,Number=1,Type=Integer,Description="Total copy number. 2 for normal diploid">', vcf_tmp, append= TRUE)
write('##INFO=<ID=LCN_EM,Number=1,Type=Integer,Description="Lesser (minor) copy number. 1 for normal diploid">', vcf_tmp, append= TRUE)
write('##INFO=<ID=CNV_ANN,Number=.,Type=String,Description="Annotation features assigned to this CNV">', vcf_tmp, append= TRUE)
write('##ALT=<ID=CNV,Description="Copy number variable region">', vcf_tmp, append= TRUE)

write(sprintf('##%sCommand=%s; Version=%s; Date=%s', getScriptName(), paste(commandArgs(), collapse= ' '), VERSION, Sys.time()), vcf_tmp, append= TRUE)

write(paste0('##purity=', fit$purity), vcf_tmp, append= TRUE)
write(paste0('##ploidy=', fit$ploidy), vcf_tmp, append= TRUE)
write(paste0('##dipLogR=', fit$dipLogR), vcf_tmp, append= TRUE)
write(paste0('##emflags="', fit$emflags, '"'), vcf_tmp, append= TRUE)

write('#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO', vcf_tmp, append= TRUE)

for(i in 1:nrow(out)){
    write(paste(facetsRecordToVcf(out[i]), collapse= '\t'), vcf_tmp, append= TRUE)
}

x_<- bgzip(vcf_tmp, dest= paste0(xargs$out, '.vcf.gz'), overwrite= TRUE)
x_<- indexTabix(paste0(xargs$out, '.vcf.gz'), format= 'vcf4')
unlink(vcf_tmp)

write(sprintf('Plotting genome...'), stderr())
png(paste0(xargs$out, '.cnv.png'), units="px", width=1600, height=1600, res=300)
sname<- sprintf('%s; ploidy= %.2f; purity= %.2f', basename(xargs$out), fit$ploidy, fit$purity)
plotSample(x=oo, emfit=fit, sname= sname)
x_ <- dev.off()

write(sprintf('Plotting spider...'), stderr())
pdf(paste0(xargs$out, '.spider.pdf'), width= 16/2.54, height= 14/2.54)
par(las= 1, mar= c(3, 3, 1, 1), mgp= c(1.5, 0.5, 0), tcl= -0.3)
logRlogORspider(oo$out, oo$dipLogR)
x_ <- dev.off()

si<- capture.output(sessionInfo())
write(si, stderr())
